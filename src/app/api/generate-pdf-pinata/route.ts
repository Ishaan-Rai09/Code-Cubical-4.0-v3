import { NextRequest, NextResponse } from 'next/server'
import { auth } from '@clerk/nextjs/server'
import jsPDF from 'jspdf'
import { mongoService } from '@/lib/mongoService'
import { pinataService } from '@/lib/pinata'
import { encryptMedicalData } from '@/lib/encryption'

export async function POST(request: NextRequest) {
  try {
    // Check authentication
    const { userId } = await auth()
    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { analysisResult } = body

    if (!analysisResult) {
      return NextResponse.json({ error: 'Analysis result is required' }, { status: 400 })
    }

    console.log('Generating PDF report for:', analysisResult.id)
    
    // Create new PDF document
    const doc = new jsPDF()
    const pageWidth = doc.internal.pageSize.width
    const margin = 20
    let yPosition = 30

    // Header
    doc.setFontSize(24)
    doc.setFont('helvetica', 'bold')
    doc.text('LuxeHealth AI - Medical Analysis Report', margin, yPosition)
    
    yPosition += 20
    doc.setFontSize(12)
    doc.setFont('helvetica', 'normal')
    doc.text(`Generated on: ${new Date(analysisResult.timestamp).toLocaleDateString()}`, margin, yPosition)
    
    yPosition += 10
    doc.text(`Report ID: ${analysisResult.id}`, margin, yPosition)
    
    // Patient Information
    yPosition += 20
    doc.setFontSize(16)
    doc.setFont('helvetica', 'bold')
    doc.text('Patient Information', margin, yPosition)
    
    yPosition += 15
    doc.setFontSize(12)
    doc.setFont('helvetica', 'normal')
    doc.text(`Name: ${analysisResult.patientName}`, margin, yPosition)
    
    yPosition += 10
    doc.text(`Image Type: ${analysisResult.imageType.charAt(0).toUpperCase() + analysisResult.imageType.slice(1)}`, margin, yPosition)
    
    // Analysis Results
    yPosition += 20
    doc.setFontSize(16)
    doc.setFont('helvetica', 'bold')
    doc.text('Analysis Results', margin, yPosition)
    
    yPosition += 15
    doc.setFontSize(12)
    doc.setFont('helvetica', 'normal')
    
    // Anomaly Status
    const statusText = analysisResult.anomalyDetected ? 'ANOMALY DETECTED' : 'NO ANOMALY DETECTED'
    const statusColor = analysisResult.anomalyDetected ? [220, 53, 69] as [number, number, number] : [40, 167, 69] as [number, number, number]
    doc.setTextColor(...statusColor)
    doc.setFont('helvetica', 'bold')
    doc.text(`Status: ${statusText}`, margin, yPosition)
    
    yPosition += 10
    doc.setTextColor(0, 0, 0)
    doc.setFont('helvetica', 'normal')
    doc.text(`Confidence: ${(analysisResult.confidence * 100).toFixed(1)}%`, margin, yPosition)
    
    // Findings
    yPosition += 20
    doc.setFontSize(14)
    doc.setFont('helvetica', 'bold')
    doc.text('Findings:', margin, yPosition)
    
    yPosition += 10
    doc.setFontSize(11)
    doc.setFont('helvetica', 'normal')
    
    analysisResult.findings.forEach((finding: string, index: number) => {
      const lines = doc.splitTextToSize(`${index + 1}. ${finding}`, pageWidth - 2 * margin)
      lines.forEach((line: string) => {
        if (yPosition > 270) {
          doc.addPage()
          yPosition = 30
        }
        doc.text(line, margin, yPosition)
        yPosition += 6
      })
      yPosition += 3
    })
    
    // Recommendations
    yPosition += 10
    doc.setFontSize(14)
    doc.setFont('helvetica', 'bold')
    doc.text('Recommendations:', margin, yPosition)
    
    yPosition += 10
    doc.setFontSize(11)
    doc.setFont('helvetica', 'normal')
    
    analysisResult.recommendations.forEach((recommendation: string, index: number) => {
      const lines = doc.splitTextToSize(`${index + 1}. ${recommendation}`, pageWidth - 2 * margin)
      lines.forEach((line: string) => {
        if (yPosition > 270) {
          doc.addPage()
          yPosition = 30
        }
        doc.text(line, margin, yPosition)
        yPosition += 6
      })
      yPosition += 3
    })
    
    // Footer
    if (yPosition > 250) {
      doc.addPage()
      yPosition = 30
    }
    
    yPosition = 280
    doc.setFontSize(10)
    doc.setFont('helvetica', 'italic')
    doc.setTextColor(128, 128, 128)
    doc.text('This report is generated by LuxeHealth AI for informational purposes only.', margin, yPosition)
    doc.text('Please consult with a healthcare professional for medical advice.', margin, yPosition + 5)
    
    // Get PDF as buffer
    const pdfBuffer = Buffer.from(doc.output('arraybuffer'))
    
    // Create file name
    const fileName = `LuxeHealth_Report_${analysisResult.patientName.replace(/\s+/g, '_')}_${analysisResult.id}.pdf`
    
    console.log('PDF report generated successfully')
    
    // Store PDF on Pinata with encryption
    let pinataHash = null
    try {
      console.log('Storing encrypted PDF on Pinata...')
      
      // Create PDF metadata
      const pdfMetadata = {
        fileName,
        fileSize: pdfBuffer.length,
        reportId: analysisResult.id,
        patientName: analysisResult.patientName,
        userId: userId,
        generatedAt: new Date().toISOString(),
        imageType: analysisResult.imageType,
        anomalyDetected: analysisResult.anomalyDetected,
        confidence: analysisResult.confidence
      }
      
      // Encrypt PDF data along with metadata
      const encryptedPdfData = encryptMedicalData({
        metadata: pdfMetadata,
        pdfData: Array.from(pdfBuffer) // Convert buffer to array for encryption
      })
      
      // Create encrypted file
      const encryptedBlob = new Blob([encryptedPdfData], { type: 'application/json' })
      const encryptedFile = new File([encryptedBlob], `${fileName}.encrypted`, { type: 'application/json' })
      
      // Upload to Pinata
      const pinataResponse = await pinataService.uploadFile(encryptedFile, {
        name: `PDF Report - ${analysisResult.patientName} - ${analysisResult.id}`,
        keyvalues: {
          userId: userId,
          analysisId: analysisResult.id,
          patientName: analysisResult.patientName,
          imageType: analysisResult.imageType,
          timestamp: new Date().toISOString(),
          dataType: 'pdf_report',
          encrypted: 'true',
          fileName: fileName
        }
      })
      
      pinataHash = pinataResponse.IpfsHash
      console.log('PDF stored on Pinata with hash:', pinataHash)
      
    } catch (pinataError) {
      console.warn('Failed to store PDF on Pinata (continuing anyway):', pinataError)
    }
    
    // Update MongoDB with PDF generation status
    try {
      const pdfHash = pinataHash || `pdf_${analysisResult.id}_${Date.now()}`
      const updateResult = await mongoService.updateAnalysisWithPDF(analysisResult.id, pdfHash)
      console.log('MongoDB updated with PDF generation:', updateResult)
    } catch (mongoError) {
      console.warn('Failed to update MongoDB with PDF status:', mongoError)
      // Continue anyway since PDF was generated successfully
    }
    
    return NextResponse.json({
      success: true,
      fileName,
      pdfBase64: pdfBuffer.toString('base64'), // For client-side download
      pinataHash: pinataHash,
      message: 'PDF report generated and stored successfully'
    })
    
  } catch (error) {
    console.error('PDF generation error:', error)
    return NextResponse.json(
      { 
        error: 'Failed to generate PDF report',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    )
  }
}